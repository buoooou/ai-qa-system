name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
        - prod
        - staging

env:
  SERVER_HOST: '3.84.225.222'
  SERVER_USER: 'ubuntu'
  PROJECT_DIR: '/home/ubuntu/ai-qa-system'

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to EC2
      run: |
        ssh -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
          set -e
          echo "ğŸš€ Starting deployment..."

          # Check if project directory exists
          if [ ! -d "${{ env.PROJECT_DIR }}" ]; then
            echo "ğŸ“‚ Creating project directory..."
            mkdir -p ${{ env.PROJECT_DIR }}
            cd ${{ env.PROJECT_DIR }}
            git clone https://github.com/${{ github.repository }}.git .
          else
            echo "ğŸ“ Updating project directory..."
            cd ${{ env.PROJECT_DIR }}
            git fetch origin
            git reset --hard origin/main
          fi

          # Check Docker and Docker Compose
          if ! command -v docker &> /dev/null; then
            echo "âŒ Docker not installed"
            exit 1
          fi

          if ! command -v docker-compose &> /dev/null; then
            echo "âŒ Docker Compose not installed"
            exit 1
          fi

          # Stop existing containers
          echo "ğŸ›‘ Stopping existing containers..."
          docker-compose down || true

          # Remove unused images and containers
          echo "ğŸ§¹ Cleaning up..."
          docker system prune -f

          # Build and start new containers
          echo "ğŸ”¨ Building and starting containers..."
          docker-compose up -d --build

          # Wait for services to start
          echo "â³ Waiting for services to start..."
          sleep 60

          # Check service status
          echo "ğŸ¥ Checking service status..."
          docker-compose ps

          # Check port status
          echo "ğŸŒ Checking port status..."
          netstat -tlnp | grep -E ':(80|8080|8081|8082|5432|6379|8848)' || echo "âš ï¸  Port check failed"

          # Health check
          echo "ğŸ” Performing health checks..."
          sleep 10

          # Check if frontend is accessible
          if curl -f http://localhost/register/ > /dev/null 2>&1; then
            echo "âœ… Frontend health check passed"
          else
            echo "âŒ Frontend health check failed"
            docker-compose logs frontend
          fi

          # Check if API Gateway is accessible
          if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
            echo "âœ… API Gateway health check passed"
          else
            echo "âŒ API Gateway health check failed"
            docker-compose logs api-gateway
          fi

          echo "âœ… Deployment completed successfully!"
        EOF

    - name: Verify deployment
      run: |
        echo "ğŸ” Verifying deployment..."
        sleep 10

        # Test frontend
        if curl -f http://${{ env.SERVER_HOST }}/register/ > /dev/null 2>&1; then
          echo "âœ… Frontend is accessible"
        else
          echo "âŒ Frontend is not accessible"
          exit 1
        fi

        # Test API Gateway
        if curl -f http://${{ env.SERVER_HOST }}:8080/actuator/health > /dev/null 2>&1; then
          echo "âœ… API Gateway is accessible"
        else
          echo "âŒ API Gateway is not accessible"
          exit 1
        fi

        echo "ğŸ‰ Deployment verification successful!"
        echo "ğŸŒ Frontend: http://${{ env.SERVER_HOST }}"
        echo "ğŸ”— API Gateway: http://${{ env.SERVER_HOST }}:8080"
