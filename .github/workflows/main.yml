name: CI/CD for AI QA System

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test-backend:
    name: Build and Test Backend Services
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        working-directory: ./backend-services
        run: mvn -B clean package

  build-and-push-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: build-and-test-backend
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Get Git commit hash and timestamp
        id: git_info
        run: |
          echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push API Gateway image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-services
          file: ./backend-services/api-gateway/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-api-gateway:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-api-gateway:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Build and push User Service image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-services
          file: ./backend-services/user-service/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-user-service:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-user-service:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Build and push QA Service image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-services
          file: ./backend-services/qa-service/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-qa-service:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-qa-service:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./ai-chatbot
          file: ./ai-chatbot/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-frontend:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-frontend:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          NACOS_SERVER_ADDR: ${{ secrets.NACOS_SERVER_ADDR }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DEPLOY_VERSION: ${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          timeout: 600s
          command_timeout: 600s
          envs: EC2_HOST,NACOS_SERVER_ADDR,GEMINI_API_KEY,JWT_SECRET,DOCKERHUB_USERNAME,DEPLOY_VERSION
          script: |
            set -euo pipefail

            echo "=== Starting deployment on EC2 ==="

            # 清理旧目录并重新克隆最新代码
            if [ -d "${HOME}/ai-qa-system" ]; then
              echo "Removing existing ai-qa-system directory..."
              rm -rf "${HOME}/ai-qa-system"
            fi

            echo "Cloning fresh repository..."
            git clone https://github.com/${{ github.repository }} "${HOME}/ai-qa-system"
            cd "${HOME}/ai-qa-system"
            git checkout main

            # 创建新的 .env 文件
            echo "Creating .env file..."
            cat > "${HOME}/ai-qa-system/.env" << EOF
            MYSQL_ROOT_PASSWORD=ai_qa_system
            MYSQL_DATABASE=ai_qa_system
            MYSQL_USER=ai_user
            MYSQL_PASSWORD=ai_user_pass

            NACOS_SERVER_ADDR=${NACOS_SERVER_ADDR}
            JWT_SECRET=${JWT_SECRET}
            GEMINI_API_KEY=${GEMINI_API_KEY}
            DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME}
            NEXT_PUBLIC_GATEWAY_URL=http://${EC2_HOST}:8083
            AUTH_SECRET=b9a8e7d6c5b4a3f2e1d0c9b8a7f6e5d4c3b2a1f0e9d8c7b6a5f4e3d2c1b0a9f8
            DEPLOY_VERSION=${DEPLOY_VERSION}
            EOF

            chmod 600 "${HOME}/ai-qa-system/.env"

            # 判断 docker compose 文件
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "Production compose file not found, using docker-compose.yml"
              COMPOSE_FILE="docker-compose.yml"
            fi

            echo "Using compose file: $COMPOSE_FILE"
            echo "Deployment version: ${DEPLOY_VERSION}"

            echo "=== 🕸️ Checking/creating Docker network (exact name: ai-qa-net) ==="
            NETWORK_NAME="ai-qa-net"

            # 如果不存在精确名称的 ai-qa-net，就创建它（这样 Compose 的 external: true ai-qa-net 能正常工作）
            if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
              echo "Network '$NETWORK_NAME' not found, creating it..."
              docker network create "$NETWORK_NAME"
            else
              echo "Network '$NETWORK_NAME' already exists."
            fi

            echo "=== 🔍 Ensuring Nacos is connected to $NETWORK_NAME ==="
            # 检查 nacos 容器是否存在（更可靠）
            if docker inspect nacos >/dev/null 2>&1; then
              echo "Nacos container detected."

              # 检查 nacos 的 NetworkSettings 中是否已经有精确的 ai-qa-net 条目
              if docker inspect nacos --format '{{json .NetworkSettings.Networks}}' | grep -q "\"${NETWORK_NAME}\""; then
                echo "Nacos is already connected to $NETWORK_NAME."
              else
                echo "Connecting Nacos to network $NETWORK_NAME ..."
                # 尝试连接（如果已经连接了也不会影响，因为上面做了判断）
                docker network connect "$NETWORK_NAME" nacos || {
                  echo "Warning: docker network connect failed (will continue)."
                }
                # 再次验证连接状态（可选）
                if docker inspect nacos --format '{{json .NetworkSettings.Networks}}' | grep -q "\"${NETWORK_NAME}\""; then
                  echo "✅ Nacos successfully connected to $NETWORK_NAME."
                else
                  echo "❗ Warning: failed to confirm Nacos connection to $NETWORK_NAME."
                fi
              fi
            else
              echo "⚠️ Warning: Nacos container not found, skipping network connect."
            fi

            echo "Stopping existing containers..."
            if docker compose -f $COMPOSE_FILE ps -q | grep -q .; then
              docker compose -f $COMPOSE_FILE down --remove-orphans || true
            fi

            echo "Cleaning up Docker resources..."
            docker system prune -f --volumes || true

            echo "Pulling latest images..."
            docker compose -f $COMPOSE_FILE pull

            echo "Starting services..."
            docker compose -f $COMPOSE_FILE up -d --remove-orphans

            echo "Waiting for services to start..."
            sleep 30

            echo "Checking service status..."
            docker compose -f $COMPOSE_FILE ps

            echo "Cleaning up old images..."
            docker image prune -f

            echo "=== Deployment completed successfully! ==="
            echo "Frontend: http://${{ secrets.EC2_HOST }}:3000"
            echo "API Gateway: http://${{ secrets.EC2_HOST }}:8083/swagger-ui.html"
